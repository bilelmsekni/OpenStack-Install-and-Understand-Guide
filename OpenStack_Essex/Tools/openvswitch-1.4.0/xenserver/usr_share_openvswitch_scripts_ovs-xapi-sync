#!/usr/bin/python
# Copyright (c) 2009, 2010, 2011 Nicira Networks
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# A daemon to monitor the external_ids columns of the Bridge and
# Interface OVSDB tables for changes that require interrogating XAPI.
# Its responsibilities include:
#
#   - Set the "bridge-id" key in the Bridge table.
#   - Set the "iface-id" key in the Interface table.
#   - Set the fail-mode on internal bridges.

import argparse
import os
import signal
import subprocess
import sys
import time

import XenAPI

import ovs.dirs
from ovs.db import error
from ovs.db import types
import ovs.util
import ovs.daemon
import ovs.db.idl

root_prefix = ''                # Prefix for absolute file names, for testing.
vlog = ovs.vlog.Vlog("ovs-xapi-sync")
vsctl = "/usr/bin/ovs-vsctl"
session = None
force_run = False


# Set up a session to interact with XAPI.
#
# On system start-up, OVS comes up before XAPI, so we can't log into the
# session until later.  Try to do this on-demand, since we won't
# actually do anything interesting until XAPI is up.
def init_session():
    global session
    if session is not None:
        return True

    try:
        session = XenAPI.xapi_local()
        session.xenapi.login_with_password("", "")
    except XenAPI.Failure, e:
        session = None
        vlog.warn("Couldn't login to XAPI (%s)" % e)
        return False

    return True


def get_network_by_bridge(br_name):
    if not init_session():
        vlog.warn("Failed to get bridge id %s because"
                " XAPI session could not be initialized" % br_name)
        return None

    for n in session.xenapi.network.get_all():
        rec = session.xenapi.network.get_record(n)
        if rec['bridge'] == br_name:
            return rec

    return None


# By default, the "bridge-id" external id in the Bridge table is the
# same as "xs-network-uuids".  This may be overridden by defining a
# "nicira-bridge-id" key in the "other_config" field of the network
# record of XAPI.  If nicira-bridge-id is undefined returns default.
# On error returns None.
def get_bridge_id(br_name, default=None):
    rec = get_network_by_bridge(br_name)
    if rec:
        return rec['other_config'].get('nicira-bridge-id', default)
    return None


# By default, the "iface-id" external id in the Interface table is the
# same as "xs-vif-uuid".  This may be overridden by defining a
# "nicira-iface-id" key in the "other_config" field of the VIF
# record of XAPI.
def get_iface_id(if_name, xs_vif_uuid):
    if not if_name.startswith("vif") and not if_name.startswith("tap"):
        # Treat whatever was passed into 'xs_vif_uuid' as a default
        # value for non-VIFs.
        return xs_vif_uuid

    if not init_session():
        vlog.warn("Failed to get interface id %s because"
                " XAPI session could not be initialized" % if_name)
        return xs_vif_uuid

    try:
        vif = session.xenapi.VIF.get_by_uuid(xs_vif_uuid)
        rec = session.xenapi.VIF.get_record(vif)
        return rec['other_config'].get('nicira-iface-id', xs_vif_uuid)
    except XenAPI.Failure:
        vlog.warn("Could not find XAPI entry for VIF %s" % if_name)
        return xs_vif_uuid


def call_vsctl(args):
    cmd = [vsctl, "--timeout=30", "-vANY:console:off"] + args
    exitcode = subprocess.call(cmd)
    if exitcode != 0:
        vlog.warn("Couldn't call ovs-vsctl")


def set_or_delete(d, key, value):
    if value is None:
        if key in d:
            del d[key]
            return True
    else:
        if d.get(key) != value:
            d[key] = value
            return True
    return False


def set_external_id(row, key, value):
    external_ids = row.external_ids
    if set_or_delete(external_ids, key, value):
        row.external_ids = external_ids


# XenServer does not call interface-reconfigure on internal networks,
# which is where the fail-mode would normally be set.
def update_fail_mode(row):
    rec = get_network_by_bridge(row.name)
    if not rec:
        return

    fail_mode = rec['other_config'].get('vswitch-controller-fail-mode')

    if not fail_mode:
        pools = session.xenapi.pool.get_all()
        if len(pools) == 1:
            prec = session.xenapi.pool.get_record(pools[0])
            fail_mode = prec['other_config'].get(
                    'vswitch-controller-fail-mode')

    if fail_mode not in ['standalone', 'secure']:
        fail_mode = 'standalone'

    if row.fail_mode != fail_mode:
        row.fail_mode = fail_mode


def update_in_band_mgmt(row):
    rec = get_network_by_bridge(row.name)
    if not rec:
        return

    dib = rec['other_config'].get('vswitch-disable-in-band')

    other_config = row.other_config
    if dib and dib not in ['true', 'false']:
        vlog.warn('"%s" isn\'t a valid setting for '
                "other_config:disable-in-band on %s" % (dib, row.name))
    elif set_or_delete(other_config, 'disable-in-band', dib):
        row.other_config = other_config


def update_bridge_id(row):
    id_ = get_bridge_id(row.name, row.external_ids.get("xs-network-uuids"))
    if not id_:
        return

    set_external_id(row, "bridge-id", id_.split(";")[0])


def keep_table_columns(schema, table_name, columns):
    table = schema.tables.get(table_name)
    if not table:
        raise error.Error("schema has no %s table" % table_name)

    new_columns = {}
    for column_name in columns:
        column = table.columns.get(column_name)
        if not column:
            raise error.Error("%s table schema lacks %s column"
                              % (table_name, column_name))
        new_columns[column_name] = column
    table.columns = new_columns
    return table


def prune_schema(schema):
    new_tables = {}
    new_tables["Bridge"] = keep_table_columns(
        schema, "Bridge", ("name", "external_ids", "other_config",
                           "fail_mode"))
    new_tables["Interface"] = keep_table_columns(
        schema, "Interface", ("name", "external_ids"))
    schema.tables = new_tables


def handler(signum, _):
    global force_run
    if (signum == signal.SIGHUP):
        force_run = True


def main():
    global force_run

    parser = argparse.ArgumentParser()
    parser.add_argument("database", metavar="DATABASE",
            help="A socket on which ovsdb-server is listening.")
    parser.add_argument("--root-prefix", metavar="DIR",
                        help="Use DIR as alternate root directory"
                        " (for testing).")

    ovs.vlog.add_args(parser)
    ovs.daemon.add_args(parser)
    args = parser.parse_args()
    ovs.vlog.handle_args(args)
    ovs.daemon.handle_args(args)

    global root_prefix
    if args.root_prefix:
        root_prefix = args.root_prefix

    remote = args.database
    schema_file = "%s/vswitch.ovsschema" % ovs.dirs.PKGDATADIR
    schema = ovs.db.schema.DbSchema.from_json(ovs.json.from_file(schema_file))
    prune_schema(schema)
    idl = ovs.db.idl.Idl(remote, schema)

    ovs.daemon.daemonize()

    # This daemon is usually started before XAPI, but to complete our
    # tasks, we need it.  Wait here until it's up.
    cookie_file = root_prefix + "/var/run/xapi_init_complete.cookie"
    while not os.path.exists(cookie_file):
        time.sleep(1)

    signal.signal(signal.SIGHUP, handler)

    bridges = {}                # Map from bridge name to xs_network_uuids
    interfaces = {}             # Map from interface name to xs-vif-uuid
    while True:
        if not force_run and not idl.run():
            poller = ovs.poller.Poller()
            idl.wait(poller)
            poller.block()
            continue

        if force_run:
            vlog.info("Forced to re-run as the result of a SIGHUP")
            bridges = {}
            interfaces = {}
            force_run = False

        txn = ovs.db.idl.Transaction(idl)

        new_bridges = {}
        for row in idl.tables["Bridge"].rows.itervalues():
            old_xnu = bridges.get(row.name)
            new_xnu = row.external_ids.get("xs-network-uuids", "")
            if old_xnu is None:
                # New bridge.
                update_fail_mode(row)
                update_in_band_mgmt(row)
            if new_xnu != old_xnu:
                # New bridge or bridge's xs-network-uuids has changed.
                update_bridge_id(row)
            new_bridges[row.name] = new_xnu
        bridges = new_bridges

        iface_by_name = {}
        for row in idl.tables["Interface"].rows.itervalues():
            iface_by_name[row.name] = row

        new_interfaces = {}
        for row in idl.tables["Interface"].rows.itervalues():
            # Match up paired vif and tap devices.
            if row.name.startswith("vif"):
                vif = row
                tap = iface_by_name.get("tap%s" % row.name[3:])
            elif row.name.startswith("tap"):
                tap = row
                vif = iface_by_name.get("vif%s" % row.name[3:])
            else:
                tap = vif = None

            # Several tap external-ids need to be copied from the vif.
            if row == tap and vif:
                keys = ["attached-mac",
                        "xs-network-uuid",
                        "xs-vif-uuid",
                        "xs-vm-uuid"]
                for k in keys:
                    set_external_id(row, k, vif.external_ids.get(k))

            # If it's a new interface or its xs-vif-uuid has changed, then
            # obtain the iface-id from XAPI.
            #
            # (A tap's xs-vif-uuid comes from its vif.  That falls out
            # naturally from the copy loop above.)
            new_xvu = row.external_ids.get("xs-vif-uuid", "")
            old_xvu = interfaces.get(row.name)
            if old_xvu != new_xvu:
                iface_id = get_iface_id(row.name, new_xvu)
                if iface_id and row.external_ids.get("iface-id") != iface_id:
                    set_external_id(row, "iface-id", iface_id)

            # When there's a vif and a tap, the tap is active (used for
            # traffic).  When there's just a vif, the vif is active.
            #
            # A tap on its own shouldn't happen, and we don't know
            # anything about other kinds of devices, so we don't use
            # an iface-status for those devices at all.
            if vif and tap:
                set_external_id(tap, "iface-status", "active")
                set_external_id(vif, "iface-status", "inactive")
            elif vif:
                set_external_id(vif, "iface-status", "active")
            else:
                set_external_id(row, "iface-status", None)

            new_interfaces[row.name] = new_xvu
        interfaces = new_interfaces

        txn.commit_block()


if __name__ == '__main__':
    try:
        main()
    except SystemExit:
        # Let system.exit() calls complete normally
        raise
    except:
        vlog.exception("traceback")
        sys.exit(ovs.daemon.RESTART_EXIT_CODE)
