#!/usr/bin/env python

# Copyright (c) 2010 Citrix Systems, Inc.
# Copyright 2010 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

#
# XenAPI plugin for managing glance images
#

import cPickle as pickle
import httplib
try:
    import json
except ImportError:
    import simplejson as json
# NOTE: XenServer 6 and below use python 2.4 so md5 is needed and not hashlib
import md5
import os
import os.path
import shlex
import shutil
import subprocess
import tempfile
import time
import urllib2

import XenAPIPlugin

#FIXME(sirp): should this use pluginlib from 5.6?
from pluginlib_nova import *
configure_logging('glance')

CHUNK_SIZE = 8192
KERNEL_DIR = '/boot/guest'


class RetryableError(Exception):
    pass


def _copy_kernel_vdi(dest, copy_args):
    vdi_uuid = copy_args['vdi_uuid']
    vdi_size = copy_args['vdi_size']
    cached_image = copy_args['cached-image']
    logging.debug("copying kernel/ramdisk file from %s to /boot/guest/%s",
                  dest, vdi_uuid)
    filename = KERNEL_DIR + '/' + vdi_uuid
    #make sure KERNEL_DIR exists, otherwise create it
    if not os.path.isdir(KERNEL_DIR):
        logging.debug("Creating directory %s", KERNEL_DIR)
        os.makedirs(KERNEL_DIR)
    #read data from /dev/ and write into a file on /boot/guest
    of = open(filename, 'wb')
    f = open(dest, 'rb')
    #copy only vdi_size bytes
    data = f.read(vdi_size)
    of.write(data)
    if cached_image:
        #create a cache file. If caching is enabled, kernel images do not have
        #to be fetched from glance.
        cached_image = KERNEL_DIR + '/' + cached_image
        logging.debug("copying kernel/ramdisk file from %s to /boot/guest/%s",
                      dest, cached_image)
        cache_file = open(cached_image, 'wb')
        cache_file.write(data)
        cache_file.close()
        logging.debug("Done. Filename: %s", cached_image)

    f.close()
    of.close()
    logging.debug("Done. Filename: %s", filename)
    return filename


def _download_tarball_and_verify(request, staging_path):
    try:
        response = urllib2.urlopen(request)
    except urllib2.HTTPError, error:
        raise RetryableError(error)
    except urllib2.URLError, error:
        raise RetryableError(error)
    except httplib.HTTPException, error:
        # httplib.HTTPException and derivatives (BadStatusLine in particular)
        # don't have a useful __repr__ or __str__
        raise RetryableError('%s: %s' % (error.__class__.__name__, error))

    tar_cmd = "tar -zx --directory=%(staging_path)s" % locals()
    tar_proc = _make_subprocess(tar_cmd, stderr=True, stdin=True)

    checksum = md5.new()
    etag = response.info().getheader('etag', None)
    if etag is None:
        etag = response.info().getheader('x-image-meta-checksum', None)

    url = request.get_full_url()
    logging.info("Reading image data from %s" % url)

    length_read = 0
    while True:
        chunk = response.read(CHUNK_SIZE)
        if chunk == '':
            break
        length_read += len(chunk)
        checksum.update(chunk)
        tar_proc.stdin.write(chunk)

    logging.info("Read %(length_read)s bytes from %(url)s" % locals())

    try:
        _finish_subprocess(tar_proc, tar_cmd)
    except Exception, error:
        raise RetryableError(error)

    checksum = checksum.hexdigest()
    if etag is None:
        msg = "No ETag found for comparison to checksum %(checksum)s"
        logging.info(msg % locals())
    elif checksum != etag:
        msg = 'ETag %(etag)s does not match computed md5sum %(checksum)s'
        raise RetryableError(msg % locals())
    else:
        msg = "Verified image checksum %(checksum)s"
        logging.info(msg % locals())


def _download_tarball(sr_path, image_id, glance_host, glance_port, auth_token):
    """Download the tarball image from Glance and extract it into the staging
    area. Retry if there is any failure.
    """
    # Build request headers
    headers = {}
    if auth_token:
        headers['x-auth-token'] = auth_token

    url = "http://%(glance_host)s:%(glance_port)d/v1/images/"\
          "%(image_id)s" % locals()
    logging.info("Downloading %s" % url)

    request = urllib2.Request(url, headers=headers)
    staging_path = _make_staging_area(sr_path)
    try:
        _download_tarball_and_verify(request, staging_path)
    except Exception:
        logging.exception('Failed to retrieve %(url)s' % locals())
        _cleanup_staging_area(staging_path)
        raise

    return staging_path


def _import_vhds(sr_path, staging_path, uuid_stack):
    """Import the VHDs found in the staging path.

    We cannot extract VHDs directly into the SR since they don't yet have
    UUIDs, aren't properly associated with each other, and would be subject to
    a race-condition of one-file being present and the other not being
    downloaded yet.

    To avoid these we problems, we use a staging area to fixup the VHDs before
    moving them into the SR. The steps involved are:

        1. Extracting tarball into staging area (done prior to this call)

        2. Renaming VHDs to use UUIDs ('snap.vhd' -> 'ffff-aaaa-...vhd')

        3. Linking VHDs together if there's a snap.vhd

        4. Pseudo-atomically moving the images into the SR. (It's not really
           atomic because it takes place as multiple os.rename operations;
           however, the chances of an SR.scan occuring between the rename()s
           invocations is so small that we can safely ignore it)

    Returns: A list of VDIs.  Each list element is a dictionary containing
    information about the VHD.  Dictionary keys are:
        1. "vdi_type" - The type of VDI. Currently they can be "os_disk" or
           "swap"
        2. "vdi_uuid" - The UUID of the VDI

    Example return: [{"vdi_type": "os_disk","vdi_uuid": "ffff-aaa..vhd"},
                     {"vdi_type": "swap","vdi_uuid": "ffff-bbb..vhd"}]
    """
    def rename_with_uuid(orig_path):
        """Rename VHD using UUID so that it will be recognized by SR on a
        subsequent scan.

        Since Python2.4 doesn't have the `uuid` module, we pass a stack of
        pre-computed UUIDs from the compute worker.
        """
        orig_dirname = os.path.dirname(orig_path)
        uuid = uuid_stack.pop()
        new_path = os.path.join(orig_dirname, "%s.vhd" % uuid)
        os.rename(orig_path, new_path)
        return new_path, uuid

    def link_vhds(child_path, parent_path):
        """Use vhd-util to associate the snapshot VHD with its base_copy.

        This needs to be done before we move both VHDs into the SR to prevent
        the base_copy from being DOA (deleted-on-arrival).
        """
        modify_cmd = ("vhd-util modify -n %(child_path)s -p %(parent_path)s"
                      % locals())
        modify_proc = _make_subprocess(modify_cmd, stderr=True)
        _finish_subprocess(modify_proc, modify_cmd)

    def move_into_sr(orig_path):
        """Move a file into the SR"""
        filename = os.path.basename(orig_path)
        new_path = os.path.join(sr_path, filename)
        os.rename(orig_path, new_path)
        return new_path

    def assert_vhd_not_hidden(path):
        """
        This is a sanity check on the image; if a snap.vhd isn't
        present, then the image.vhd better not be marked 'hidden' or it will
        be deleted when moved into the SR.
        """
        query_cmd = "vhd-util query -n %(path)s -f" % locals()
        query_proc = _make_subprocess(query_cmd, stdout=True, stderr=True)
        out, err = _finish_subprocess(query_proc, query_cmd)

        for line in out.splitlines():
            if line.startswith('hidden'):
                value = line.split(':')[1].strip()
                if value == "1":
                    raise Exception(
                        "VHD %(path)s is marked as hidden without child" %
                        locals())

    def prepare_if_exists(staging_path, vhd_name, parent_path=None):
        """
        Check for existance of a particular VHD in the staging path and
        preparing it for moving into the SR.

        Returns: Tuple of (Path to move into the SR, VDI_UUID)
                 None, if the vhd_name doesn't exist in the staging path

        If the VHD exists, we will do the following:
            1. Rename it with a UUID.
            2. If parent_path exists, we'll link up the VHDs.
        """
        orig_path = os.path.join(staging_path, vhd_name)
        if not os.path.exists(orig_path):
            return None
        new_path, vdi_uuid = rename_with_uuid(orig_path)
        if parent_path:
            # NOTE(sirp): this step is necessary so that an SR scan won't
            # delete the base_copy out from under us (since it would be
            # orphaned)
            link_vhds(new_path, parent_path)
        return (new_path, vdi_uuid)

    def validate_vdi_chain(vdi_path):
        """
        This check ensures that the parent pointers on the VHDs are valid
        before we move the VDI chain to the SR. This is *very* important
        because a bad parent pointer will corrupt the SR causing a cascade of
        failures.
        """
        def get_parent_path(path):
            query_cmd = "vhd-util query -n %(path)s -p" % locals()
            query_proc = _make_subprocess(query_cmd, stdout=True, stderr=True)
            out, err = _finish_subprocess(
                    query_proc, query_cmd, ok_exit_codes=[0, 22])
            first_line = out.splitlines()[0].strip()
            if first_line.endswith(".vhd"):
                return first_line
            elif 'has no parent' in first_line:
                return None
            elif 'query failed' in first_line:
                raise Exception("VDI '%(path)s' not present which breaks"
                                " the VDI chain, bailing out" % locals())
            else:
                raise Exception("Unexpected output '%(out)s' from vhd-util" %
                                locals())

        cur_path = vdi_path
        while cur_path:
            cur_path = get_parent_path(cur_path)

    vdi_return_list = []
    paths_to_move = []

    image_parent = None
    base_info = prepare_if_exists(staging_path, 'base.vhd')
    if base_info:
        paths_to_move.append(base_info[0])
        image_parent = base_info[0]

    image_info = prepare_if_exists(staging_path, 'image.vhd', image_parent)
    if not image_info:
        raise Exception("Invalid image: image.vhd not present")

    paths_to_move.insert(0, image_info[0])

    snap_info = prepare_if_exists(staging_path, 'snap.vhd',
            image_info[0])
    if snap_info:
        validate_vdi_chain(snap_info[0])
        # NOTE(sirp): this is an insert rather than an append since the
        # 'snapshot' vhd needs to be copied into the SR before the base copy.
        # If it doesn't, then there is a possibliity that snapwatchd will
        # delete the base_copy since it is an unreferenced parent.
        paths_to_move.insert(0, snap_info[0])
        # We return this snap as the VDI instead of image.vhd
        vdi_return_list.append(dict(vdi_type="os", vdi_uuid=snap_info[1]))
    else:
        validate_vdi_chain(image_info[0])
        assert_vhd_not_hidden(image_info[0])
        # If there's no snap, we return the image.vhd UUID
        vdi_return_list.append(dict(vdi_type="os", vdi_uuid=image_info[1]))

    swap_info = prepare_if_exists(staging_path, 'swap.vhd')
    if swap_info:
        assert_vhd_not_hidden(swap_info[0])
        paths_to_move.append(swap_info[0])
        vdi_return_list.append(dict(vdi_type="swap", vdi_uuid=swap_info[1]))

    for path in paths_to_move:
        move_into_sr(path)

    return vdi_return_list


def _prepare_staging_area_for_upload(sr_path, staging_path, vdi_uuids):
    """Hard-link VHDs into staging area with appropriate filename
    ('snap' or 'image.vhd')
    """
    for name, uuid in vdi_uuids.items():
        if uuid:
            source = os.path.join(sr_path, "%s.vhd" % uuid)
            link_name = os.path.join(staging_path, "%s.vhd" % name)
            os.link(source, link_name)


def _upload_tarball(staging_path, image_id, glance_host, glance_port,
                    auth_token, properties):
    """
    Create a tarball of the image and then stream that into Glance
    using chunked-transfer-encoded HTTP.
    """
    url = 'http://%s:%s/v1/images/%s' % (glance_host, glance_port, image_id)
    logging.info("Writing image data to %s" % url)
    conn = httplib.HTTPConnection(glance_host, glance_port)

    # NOTE(sirp): httplib under python2.4 won't accept a file-like object
    # to request
    conn.putrequest('PUT', '/v1/images/%s' % image_id)

    # NOTE(sirp): There is some confusion around OVF. Here's a summary of
    # where we currently stand:
    #   1. OVF as a container format is misnamed. We really should be using
    #      OVA since that is the name for the container format; OVF is the
    #      standard applied to the manifest file contained within.
    #   2. We're currently uploading a vanilla tarball. In order to be OVF/OVA
    #      compliant, we'll need to embed a minimal OVF manifest as the first
    #      file.

    # NOTE(dprince): In order to preserve existing Glance properties
    # we set X-Glance-Registry-Purge-Props on this request.
    headers = {
        'content-type': 'application/octet-stream',
        'transfer-encoding': 'chunked',
        'x-image-meta-is-public': 'False',
        'x-image-meta-status': 'queued',
        'x-image-meta-disk-format': 'vhd',
        'x-image-meta-container-format': 'ovf',
        'x-glance-registry-purge-props': 'False'}

    # If we have an auth_token, set an x-auth-token header
    if auth_token:
        headers['x-auth-token'] = auth_token

    for key, value in properties.iteritems():
        header_key = "x-image-meta-property-%s" % key.replace('_', '-')
        headers[header_key] = str(value)

    for header, value in headers.iteritems():
        conn.putheader(header, value)
    conn.endheaders()

    tar_cmd = "tar -zc --directory=%(staging_path)s ." % locals()
    tar_proc = _make_subprocess(tar_cmd, stdout=True, stderr=True)

    length = 0
    chunk = tar_proc.stdout.read(CHUNK_SIZE)
    while chunk:
        length += len(chunk)
        conn.send("%x\r\n%s\r\n" % (len(chunk), chunk))
        chunk = tar_proc.stdout.read(CHUNK_SIZE)
    conn.send("0\r\n\r\n")
    logging.info("Wrote %s bytes to %s" % (length, url))

    _finish_subprocess(tar_proc, tar_cmd)

    resp = conn.getresponse()
    if resp.status != httplib.OK:
        logging.error("Unexpected response while writing image data to %s: "
                      "Response Status: %i, Response body: %s"
                      % (url, resp.status, resp.read()))
        raise Exception("Unexpected response [%i] while uploading image [%s] "
                        "to glance host [%s:%s]"
                        % (resp.status, image_id, glance_host, glance_port))
    conn.close()


def _make_staging_area(sr_path):
    """
    The staging area is a place where we can temporarily store and
    manipulate VHDs. The use of the staging area is different for upload and
    download:

    Download
    ========

    When we download the tarball, the VHDs contained within will have names
    like "snap.vhd" and "image.vhd". We need to assign UUIDs to them before
    moving them into the SR. However, since 'image.vhd' may be a base_copy, we
    need to link it to 'snap.vhd' (using vhd-util modify) before moving both
    into the SR (otherwise the SR.scan will cause 'image.vhd' to be deleted).
    The staging area gives us a place to perform these operations before they
    are moved to the SR, scanned, and then registered with XenServer.

    Upload
    ======

    On upload, we want to rename the VHDs to reflect what they are, 'snap.vhd'
    in the case of the snapshot VHD, and 'image.vhd' in the case of the
    base_copy. The staging area provides a directory in which we can create
    hard-links to rename the VHDs without affecting what's in the SR.


    NOTE
    ====

    The staging area is created as a subdirectory within the SR in order to
    guarantee that it resides within the same filesystem and therefore permit
    hard-linking and cheap file moves.
    """
    staging_path = tempfile.mkdtemp(dir=sr_path)
    return staging_path


def _cleanup_staging_area(staging_path):
    """Remove staging area directory

    On upload, the staging area contains hard-links to the VHDs in the SR;
    it's safe to remove the staging-area because the SR will keep the link
    count > 0 (so the VHDs in the SR will not be deleted).
    """
    if os.path.exists(staging_path):
        shutil.rmtree(staging_path)


def _make_subprocess(cmdline, stdout=False, stderr=False, stdin=False):
    """Make a subprocess according to the given command-line string
    """
    kwargs = {}
    kwargs['stdout'] = stdout and subprocess.PIPE or None
    kwargs['stderr'] = stderr and subprocess.PIPE or None
    kwargs['stdin'] = stdin and subprocess.PIPE or None
    args = shlex.split(cmdline)
    proc = subprocess.Popen(args, **kwargs)
    return proc


def _finish_subprocess(proc, cmdline, ok_exit_codes=None):
    """Ensure that the process returned a zero exit code indicating success
    """
    if ok_exit_codes is None:
        ok_exit_codes = [0]

    out, err = proc.communicate()
    ret = proc.returncode
    if ret not in ok_exit_codes:
        raise Exception("'%(cmdline)s' returned non-zero exit code: "
                        "retcode=%(ret)i, out='%(out)s', stderr='%(err)s'"
                        % locals())
    return out, err


def create_kernel_ramdisk(session, args):
    """Creates a copy of the kernel/ramdisk image if it is present in the
    cache. If the image is not present in the cache, it does nothing.
    """
    cached_image = exists(args, 'cached-image')
    image_uuid = exists(args, 'new-image-uuid')
    cached_image_filename = KERNEL_DIR + '/' + cached_image
    filename = KERNEL_DIR + '/' + image_uuid

    if os.path.isfile(cached_image_filename):
        shutil.copyfile(cached_image_filename, filename)
        logging.debug("Done. Filename: %s", filename)
    else:
        filename = ""
        logging.debug("Cached kernel/ramdisk image not found")
    return filename


def download_vhd(session, args):
    """Download an image from Glance, unbundle it, and then deposit the VHDs
    into the storage repository
    """
    params = pickle.loads(exists(args, 'params'))
    image_id = params["image_id"]
    glance_host = params["glance_host"]
    glance_port = params["glance_port"]
    uuid_stack = params["uuid_stack"]
    sr_path = params["sr_path"]
    auth_token = params["auth_token"]

    staging_path = None
    try:
        staging_path = _download_tarball(sr_path, image_id, glance_host,
                                         glance_port, auth_token)
        # Right now, it's easier to return a single string via XenAPI,
        # so we'll json encode the list of VHDs.
        return json.dumps(_import_vhds(sr_path, staging_path, uuid_stack))
    finally:
        if staging_path is not None:
            _cleanup_staging_area(staging_path)


def upload_vhd(session, args):
    """Bundle the VHDs comprising an image and then stream them into Glance.
    """
    params = pickle.loads(exists(args, 'params'))
    vdi_uuids = params["vdi_uuids"]
    image_id = params["image_id"]
    glance_host = params["glance_host"]
    glance_port = params["glance_port"]
    sr_path = params["sr_path"]
    auth_token = params["auth_token"]
    properties = params["properties"]

    staging_path = _make_staging_area(sr_path)
    try:
        _prepare_staging_area_for_upload(sr_path, staging_path, vdi_uuids)
        _upload_tarball(staging_path, image_id, glance_host, glance_port,
                        auth_token, properties)
    finally:
        _cleanup_staging_area(staging_path)

    return ""  # Nothing useful to return on an upload


def copy_kernel_vdi(session, args):
    vdi = exists(args, 'vdi-ref')
    size = exists(args, 'image-size')
    cached_image = optional(args, 'cached-image')
    #Use the uuid as a filename
    vdi_uuid = session.xenapi.VDI.get_uuid(vdi)
    copy_args = {'vdi_uuid': vdi_uuid,
                 'vdi_size': int(size),
                 'cached-image': cached_image}
    filename = with_vdi_in_dom0(session, vdi, False,
                                lambda dev:
                               _copy_kernel_vdi('/dev/%s' % dev, copy_args))
    return filename


def remove_kernel_ramdisk(session, args):
    """Removes kernel and/or ramdisk from dom0's file system"""
    kernel_file = optional(args, 'kernel-file')
    ramdisk_file = optional(args, 'ramdisk-file')
    if kernel_file:
        os.remove(kernel_file)
    if ramdisk_file:
        os.remove(ramdisk_file)
    return "ok"


if __name__ == '__main__':
    XenAPIPlugin.dispatch({'upload_vhd': upload_vhd,
                           'download_vhd': download_vhd,
                           'copy_kernel_vdi': copy_kernel_vdi,
                           'create_kernel_ramdisk': create_kernel_ramdisk,
                           'remove_kernel_ramdisk': remove_kernel_ramdisk})
